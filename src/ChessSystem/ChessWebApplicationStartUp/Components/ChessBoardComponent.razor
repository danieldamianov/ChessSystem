@using ChessGameLogic
@using ChessGameLogic.ClientInteractionEntities
@using ChessGameLogic.Enums
@using System.Reflection;
@using ChessSystem.Application.Common.Interfaces
@using System.Collections.Concurrent;

@* Imports for blazor *@
@using System.Net.Http
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop

@inject IJSRuntime JSRuntime
@inject ICurrentUser currentUser

<h3>Chess board</h3>
<br />
@{
    var chessFieldColor = "White";
}
<div id="chessBoard" style="font-size: 0px;">
    @if (this.chessColor == ChessColors.White)
    {
        @for (int vertical = 8; vertical >= 1; vertical--)
        {
            for (char horizontal = 'a'; horizontal <= 'h'; horizontal++)
            {
                if (horizontal != 'a')
                {
                    if (chessFieldColor == "White")
                    {
                        chessFieldColor = "Darkgray";
                    }
                    else
                    {
                        chessFieldColor = "White";
                    }

                }
                var figureInfo = this.chessGame.GetFigureOnPositionInfo(horizontal, vertical);


                char hor = horizontal;
                int ver = vertical;

                this.ChessBoardContainerInstance.SetInfo(hor, ver, figureInfo);
                <button @onclick="@(e =>
                                        HandleFieldPressed(e, hor, ver, this.ChessBoardContainerInstance.GetInfo(hor, ver)?.figureType,
                                        this.ChessBoardContainerInstance.GetInfo(hor, ver)?.figureColor))"
                        id="@(horizontal.ToString() + vertical)field"
                        style="margin:0px; border: none; width: 70px; height:70px; background-color: @chessFieldColor">
                    @if (figureInfo != null)
                    {
                        <img style="width: 50px; height:50px" src="/ImagesForFigures/@($"{figureInfo.figureType}{figureInfo.figureColor}{chessFieldColor}").jpg" alt="Alternate Text" />
                    }
                    else
                    {
                        <img style="width: 50px; height:50px" src="/ImagesForFigures/@($"{chessFieldColor}").jpg" alt="Alternate Text" />
                    }
                </button>
            }
            <br />
        }
    }
    else
    {
        @for (int vertical = 1; vertical <= 8; vertical++)
        {
            for (char horizontal = 'h'; horizontal >= 'a'; horizontal--)
            {
                if (horizontal != 'h')
                {
                    if (chessFieldColor == "White")
                    {
                        chessFieldColor = "Darkgray";
                    }
                    else
                    {
                        chessFieldColor = "White";
                    }

                }
                var figureInfo = this.chessGame.GetFigureOnPositionInfo(horizontal, vertical);

                char hor = horizontal;
                int ver = vertical;

                this.ChessBoardContainerInstance.SetInfo(hor, ver, figureInfo);
                <button @onclick="@(e =>
                                        HandleFieldPressed(e, hor, ver, this.ChessBoardContainerInstance.GetInfo(hor, ver)?.figureType,
                                        this.ChessBoardContainerInstance.GetInfo(hor, ver)?.figureColor))"
                        id="@(horizontal.ToString() + vertical)field" style="margin:0px; border: none; width: 70px; height:70px; background-color: @chessFieldColor">
                    @if (figureInfo != null)
                    {
                        <img style="width: 50px; height:50px" src="/ImagesForFigures/@($"{this.ChessBoardContainerInstance.GetInfo(hor, ver)?.figureType}{this.ChessBoardContainerInstance.GetInfo(hor, ver)?.figureColor}{chessFieldColor}").jpg" alt="Alternate Text" />
                    }
                    else
                    {
                        <img style="width: 50px; height:50px" src="/ImagesForFigures/@($"{chessFieldColor}").jpg" alt="Alternate Text" />
                    }
                </button>
            }
            <br />
        }
    }


</div>

@code {

    private static ConcurrentDictionary<string, Action<string, string, string, string, string, string>> opponentHasMadeMoveHandlers
        = new ConcurrentDictionary<string, Action<string, string, string, string, string, string>>();

    protected override void OnInitialized()
    {
        if (opponentHasMadeMoveHandlers.ContainsKey(this.currentUser.UserId))
        {
            opponentHasMadeMoveHandlers.TryRemove(this.currentUser.UserId, out Action<string, string, string, string, string, string> value);
        }

        opponentHasMadeMoveHandlers.TryAdd(this.currentUser.UserId, OpponentHasMadeMoveHandle);

    }

    private void OpponentHasMadeMoveHandle(
            string initialPositionHorizontal,
            string initialPositionVertical,
            string targetPositionHorizontal,
            string targetPositionVertical,
            string figureType,
            string figureColor)
    {
        this.chessGame.NormalMove(initialPositionHorizontal[0], int.Parse(initialPositionVertical),
                    targetPositionHorizontal[0], int.Parse(targetPositionVertical),
                    Enum.Parse<ChessFigureType>(figureType), Enum.Parse<ChessColors>(figureColor));

        this.UpdateChessBoardContainerInstance();


        this.IsOnTurn = true;

        EnableAndDisableFielsAccordingTurn().GetAwaiter();

        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    [JSInvokable]
    public static Task OpponentHasMadeMove(
            string opponentId,
            string initialPositionHorizontal,
            string initialPositionVertical,
            string targetPositionHorizontal,
            string targetPositionVertical,
            string figureType,
            string figureColor)
    {
        opponentHasMadeMoveHandlers.TryGetValue(opponentId, out Action<string, string, string, string, string, string> value);
        value.Invoke(initialPositionHorizontal,
            initialPositionVertical,
            targetPositionHorizontal,
            targetPositionVertical,
            figureType,
            figureColor);

        return Task.CompletedTask;
    }



    [Parameter]
    public string WhitePlayerId { get; set; }

    [Parameter]
    public string BlackPlayerId { get; set; }

    public string OpponentId => this.chessColor == ChessColors.White ? BlackPlayerId : WhitePlayerId;

    private ChessGame chessGame;

    [Parameter]
    public bool IsOnTurn { get; set; }

    private Tuple<char, int> currentSelectedField = null;

    private ChessBoardContainer ChessBoardContainerInstance = new ChessBoardContainer();

    private ChessFigureOnPositionInfo[,] chessFigureOnPositionInfo = new ChessFigureOnPositionInfo[8, 8];

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender == false)
        {
            return;
        }
        await EnableAndDisableFielsAccordingTurn();

        await base.OnAfterRenderAsync(firstRender);
    }

    [Parameter]
    public ChessColors chessColor { get; set; }

    public ChessBoardComponent()
    {
        this.chessGame = new ChessGame(ChooseFigureToProduce, HandleGameEnding);
    }

    private ChessFigureProductionType ChooseFigureToProduce()
    {
        return ChessFigureProductionType.Queen;
    }

    private void HandleGameEnding(EndGameResult endGameResult)
    {

    }

    public class ChessBoardContainer
    {
        private Dictionary<char, Dictionary<int, ChessFigureOnPositionInfo>> board = new Dictionary<char, Dictionary<int, ChessFigureOnPositionInfo>>();

        public void SetInfo(char horizontal, int vertical, ChessFigureOnPositionInfo chessFigureOnPositionInfo)
        {
            if (this.board.ContainsKey(horizontal) == false)
            {
                this.board[horizontal] = new Dictionary<int, ChessFigureOnPositionInfo>();
            }
            this.board[horizontal][vertical] = chessFigureOnPositionInfo;
        }

        public ChessFigureOnPositionInfo GetInfo(char horizontal, int vertical)
        {
            return this.board[horizontal][vertical];
        }
    }

    public class BoardPosition
    {
        public char Horizontal { get; set; }

        public int Vertical { get; set; }

        public BoardPosition(char horizontal, int vertical)
        {
            this.Horizontal = horizontal;
            this.Vertical = vertical;
        }
    }

    private List<BoardPosition> GetBoardPositionsExceptGiven(List<BoardPosition> given)
    {
        var positions = new List<BoardPosition>();

        for (char i = 'a'; i <= 'h'; i++)
        {
            for (int j = 1; j <= 8; j++)
            {
                if (given.Any(pos => pos.Horizontal == i && pos.Vertical == j) == false)
                {
                    positions.Add(new BoardPosition(i, j));
                }
            }
        }

        return positions;
    }

    private async Task HandleFieldPressed(MouseEventArgs e, char horizontal, int vertical, ChessFigureType? chessFigureType, ChessColors? chessColors)
    {
        if (currentSelectedField == null)
        {
            currentSelectedField = new Tuple<char, int>(horizontal, vertical);

            var possiblePositions = this.chessGame.GetAllPossiblePositionsOfPlacingTheFigure(horizontal,
                vertical, (ChessFigureType)chessFigureType, (ChessColors)chessColors);

            var positionsToEnable = possiblePositions.Select(pos => new BoardPosition(pos.Horizontal, pos.Vertical))
                .ToList();

            positionsToEnable.Add(new BoardPosition(this.currentSelectedField.Item1, this.currentSelectedField.Item2));

            var positionsToDisable = GetBoardPositionsExceptGiven(positionsToEnable);


            await JSRuntime.InvokeVoidAsync("enableButtons", positionsToEnable);
            await JSRuntime.InvokeVoidAsync("disableButtons", positionsToDisable);
        }
        else
        {
            if (currentSelectedField.Item1 == horizontal && currentSelectedField.Item2 == vertical)
            {
                await this.EnableAndDisableFielsAccordingTurn();
            }
            else
            {
                var figureInfo = this.ChessBoardContainerInstance.GetInfo(currentSelectedField.Item1, currentSelectedField.Item2);

                this.chessGame.NormalMove(currentSelectedField.Item1, currentSelectedField.Item2,
                    horizontal, vertical, figureInfo.figureType, figureInfo.figureColor);

                this.UpdateChessBoardContainerInstance();

                this.IsOnTurn = false;

                await EnableAndDisableFielsAccordingTurn();

                string assemblyname = Assembly.GetExecutingAssembly().GetName().Name;

                await JSRuntime.InvokeVoidAsync("SendMove", OpponentId.ToString(),
                    currentSelectedField.Item1.ToString(),
                    currentSelectedField.Item2.ToString(),
                    horizontal.ToString(),
                    vertical.ToString(),
                    figureInfo.figureType.ToString(),
                    figureInfo.figureColor.ToString());
            }
            currentSelectedField = null;
        }

    }

    private void UpdateChessBoardContainerInstance()
    {
        for (char i = 'a'; i <= 'h'; i++)
        {
            for (int j = 1; j <= 8; j++)
            {
                this.ChessBoardContainerInstance.SetInfo(i, j, this.chessGame.GetFigureOnPositionInfo(i, j));
            }
        }
    }

    private async Task EnableAndDisableFielsAccordingTurn()
    {
        if (this.IsOnTurn == false)
        {
            List<BoardPosition> boardPositions = new List<BoardPosition>();
            for (char i = 'a'; i <= 'h'; i++)
            {
                for (int j = 1; j <= 8; j++)
                {
                    boardPositions.Add(new BoardPosition(i, j));
                }
            }

            await JSRuntime.InvokeVoidAsync("disableButtons", boardPositions);
        }
        else
        {
            List<BoardPosition> boardPositions = new List<BoardPosition>();
            for (char i = 'a'; i <= 'h'; i++)
            {
                for (int j = 1; j <= 8; j++)
                {
                    if (this.ChessBoardContainerInstance.GetInfo(i, j) == null
                        || this.ChessBoardContainerInstance.GetInfo(i, j).figureColor != chessColor)
                    {
                        boardPositions.Add(new BoardPosition(i, j));
                    }
                }
            }

            await JSRuntime.InvokeVoidAsync("disableButtons", boardPositions);
            await JSRuntime.InvokeVoidAsync("enableButtons", GetBoardPositionsExceptGiven(boardPositions));
        }
    }
}
